interface FacilitatorConfig {
    /** Facilitator URL (defaults to https://pay.openfacilitator.io) */
    url?: string;
    /** Optional timeout in ms (default: 30000) */
    timeout?: number;
    /** Optional custom headers */
    headers?: Record<string, string>;
}
/**
 * Payment payload for x402 version 1. Uses flat structure with scheme/network at top level.
 */
interface PaymentPayloadV1 {
    /** x402 version 1 */
    x402Version: 1;
    /** Payment scheme (e.g., "exact") */
    scheme: string;
    /** Network identifier - v1 format (e.g., "base", "solana") */
    network: string;
    /** Payment details */
    payload: {
        /** Signature of the payment */
        signature: string;
        /** Payment authorization */
        authorization: PaymentAuthorization;
    };
}
/**
 * Payment payload for x402 version 2. Uses nested `accepted` structure per @x402/core spec.
 */
interface PaymentPayloadV2 {
    /** x402 version 2 */
    x402Version: 2;
    /** Optional resource being paid for */
    resource?: {
        /** Resource URL */
        url: string;
        /** Human-readable description */
        description?: string;
        /** MIME type of resource */
        mimeType?: string;
    };
    /** Accepted payment requirements (contains scheme, network, amount, etc.) */
    accepted: {
        /** Payment scheme (e.g., "exact") */
        scheme: string;
        /** Network identifier - CAIP-2 format (e.g., "eip155:8453") */
        network: string;
        /** Token/asset address */
        asset: string;
        /** Amount in base units */
        amount: string;
        /** Recipient address */
        payTo: string;
        /** Maximum timeout in seconds */
        maxTimeoutSeconds: number;
        /** Extra data */
        extra?: Record<string, unknown>;
    };
    /** Payment details (signature, authorization, etc.) */
    payload: Record<string, unknown>;
    /** Optional extensions */
    extensions?: Record<string, unknown>;
}
/**
 * Payment payload union - supports both x402 v1 and v2 formats.
 * Use x402Version to discriminate between versions.
 */
type PaymentPayload = PaymentPayloadV1 | PaymentPayloadV2;
interface PaymentAuthorization {
    /** Sender address */
    from: string;
    /** Recipient address */
    to: string;
    /** Amount in base units (string to handle large numbers) */
    amount: string;
    /** Token/asset address or identifier */
    asset: string;
    /** Chain ID (for EVM) */
    chainId?: number;
    /** Nonce */
    nonce?: string;
    /** Expiration timestamp */
    validUntil?: number;
    /** Additional fields for specific schemes */
    [key: string]: unknown;
}
/**
 * Payment requirements for x402 version 1. Uses maxAmountRequired field.
 */
interface PaymentRequirementsV1 {
    /** Payment scheme (e.g., "exact") */
    scheme: string;
    /** Network identifier */
    network: string;
    /** Maximum amount required in base units */
    maxAmountRequired: string;
    /** Resource URL being paid for */
    resource?: string;
    /** Token/asset address */
    asset: string;
    /** Recipient address */
    payTo?: string;
    /** Human-readable description */
    description?: string;
    /** MIME type of resource */
    mimeType?: string;
    /** Maximum timeout in seconds */
    maxTimeoutSeconds?: number;
    /** Output schema for structured responses */
    outputSchema?: Record<string, unknown>;
    /** Extra data */
    extra?: Record<string, unknown>;
}
/**
 * Payment requirements for x402 version 2.
 * Uses 'amount' instead of 'maxAmountRequired' and has stricter required fields.
 */
interface PaymentRequirementsV2 {
    /** Payment scheme (e.g., "exact") */
    scheme: string;
    /** Network identifier - v2 CAIP-2 format */
    network: string;
    /** Amount required in base units */
    amount: string;
    /** Token/asset address */
    asset: string;
    /** Recipient address */
    payTo: string;
    /** Maximum timeout in seconds */
    maxTimeoutSeconds: number;
    /** Extra data */
    extra: Record<string, unknown>;
}
/**
 * Payment requirements union - supports both v1 and v2 formats.
 * V1 uses maxAmountRequired, V2 uses amount.
 */
type PaymentRequirements = PaymentRequirementsV1 | PaymentRequirementsV2;
interface VerifyResponse {
    /** Whether the payment is valid */
    isValid: boolean;
    /** Reason if invalid (x402 standard) */
    invalidReason?: string;
    /** Payer address */
    payer?: string;
    /** Additional verification details */
    details?: {
        /** Verified amount */
        amount?: string;
        /** Verified recipient */
        recipient?: string;
        /** Payment scheme used */
        scheme?: string;
    };
}
interface SettleResponse {
    /** Whether settlement was successful */
    success: boolean;
    /** Transaction hash/signature (empty string when failed, x402 standard) */
    transaction: string;
    /** Payer address (x402 standard) */
    payer: string;
    /** Network the transaction was settled on */
    network: string;
    /** Error reason if failed (x402 standard) */
    errorReason?: string;
}
interface SupportedResponse {
    /** Supported payment kinds */
    kinds: PaymentKind[];
    /** Signer addresses by network namespace */
    signers?: Record<string, string[]>;
    /** Supported extensions */
    extensions?: string[];
}
interface PaymentKind {
    /** x402 version */
    x402Version: 1 | 2;
    /** Payment scheme */
    scheme: string;
    /** Network identifier */
    network: string;
    /** Extra data (e.g., feePayer for Solana) */
    extra?: {
        feePayer?: string;
        [key: string]: unknown;
    };
}
type NetworkType = 'evm' | 'solana';
interface NetworkInfo {
    /** v1 identifier (e.g., "base") */
    v1Id: string;
    /** v2 CAIP-2 identifier (e.g., "eip155:8453") */
    v2Id: string;
    /** Human-readable name */
    name: string;
    /** Network type */
    type: NetworkType;
    /** Chain ID (EVM only) */
    chainId?: number;
    /** Whether this is a testnet */
    testnet: boolean;
}

declare class OpenFacilitator {
    private readonly baseUrl;
    private readonly timeout;
    private readonly headers;
    private supportedCache;
    private supportedPromise;
    constructor(config?: FacilitatorConfig);
    /**
     * Get the facilitator URL
     */
    get url(): string;
    /**
     * Verify a payment is valid
     * @param payment - The payment payload
     * @param requirements - Payment requirements for validation
     */
    verify(payment: PaymentPayload, requirements: PaymentRequirements): Promise<VerifyResponse>;
    /**
     * Settle/broadcast a payment transaction
     * @param payment - The payment payload
     * @param requirements - Payment requirements for validation
     */
    settle(payment: PaymentPayload, requirements: PaymentRequirements): Promise<SettleResponse>;
    /**
     * Get supported networks and payment kinds
     */
    supported(): Promise<SupportedResponse>;
    /**
     * Health check - verify facilitator is reachable
     */
    health(): Promise<boolean>;
    /**
     * Get fee payer address for a specific network.
     * Fee payers are wallet addresses that pay transaction fees when settling payments.
     * Currently only Solana networks have fee payers.
     * @param network - Network identifier (e.g., "solana", "solana:mainnet")
     * @returns Fee payer address or undefined if not available for the network
     */
    getFeePayer(network: string): Promise<string | undefined>;
    /**
     * Get all fee payers mapped by network.
     * Fee payers are wallet addresses that pay transaction fees when settling payments.
     * @returns Map of network identifiers to fee payer addresses
     */
    getFeePayerMap(): Promise<Record<string, string>>;
    /**
     * Get cached supported response, fetching if needed.
     * Uses deduplication to prevent concurrent requests.
     */
    private getSupportedCached;
    /**
     * Clear cached supported response.
     * Useful if facilitator configuration may have changed.
     */
    clearCache(): void;
    /**
     * Internal request helper
     */
    private request;
}
/**
 * Create a facilitator client with default OpenFacilitator URL
 * @deprecated Just use `new OpenFacilitator()` - it defaults to the public endpoint
 */
declare function createDefaultFacilitator(): OpenFacilitator;

declare class FacilitatorError extends Error {
    code: string;
    statusCode?: number | undefined;
    details?: unknown | undefined;
    constructor(message: string, code: string, statusCode?: number | undefined, details?: unknown | undefined);
}
declare class NetworkError extends FacilitatorError {
    constructor(message: string, details?: unknown);
}
declare class VerificationError extends FacilitatorError {
    constructor(message: string, details?: unknown);
}
declare class SettlementError extends FacilitatorError {
    constructor(message: string, details?: unknown);
}
declare class ConfigurationError extends FacilitatorError {
    constructor(message: string);
}

declare const NETWORKS: NetworkInfo[];
/**
 * Get network info by v1 or v2 identifier
 */
declare function getNetwork(id: string): NetworkInfo | undefined;
/**
 * Get network type from identifier
 */
declare function getNetworkType(id: string): 'evm' | 'solana' | undefined;
/**
 * Convert v1 network ID to v2 (CAIP-2)
 */
declare function toV2NetworkId(id: string): string;
/**
 * Convert v2 network ID to v1
 */
declare function toV1NetworkId(id: string): string;
/**
 * Check if network ID is valid
 */
declare function isValidNetwork(id: string): boolean;
/**
 * Get all mainnet networks
 */
declare function getMainnets(): NetworkInfo[];
/**
 * Get all testnet networks
 */
declare function getTestnets(): NetworkInfo[];

/**
 * Type guard for checking if value is a valid payment payload
 */
declare function isPaymentPayload(value: unknown): value is PaymentPayload;
/**
 * Type guard for PaymentPayloadV1 (x402 version 1).
 * Narrows PaymentPayload to v1 format with flat structure.
 */
declare function isPaymentPayloadV1(value: unknown): value is PaymentPayloadV1;
/**
 * Type guard for PaymentPayloadV2 (x402 version 2).
 * Narrows PaymentPayload to v2 format with nested `accepted` structure.
 */
declare function isPaymentPayloadV2(value: unknown): value is PaymentPayloadV2;
/**
 * Type guard for PaymentRequirementsV1.
 * V1 requirements have maxAmountRequired field.
 */
declare function isPaymentRequirementsV1(value: unknown): value is PaymentRequirementsV1;
/**
 * Type guard for PaymentRequirementsV2.
 * V2 requirements have amount but NOT maxAmountRequired.
 */
declare function isPaymentRequirementsV2(value: unknown): value is PaymentRequirementsV2;
/**
 * Extract scheme and network from PaymentPayload (version-agnostic).
 * v1 has these at top level, v2 has them nested in `accepted`.
 */
declare function getSchemeNetwork(payload: PaymentPayload): {
    scheme: string;
    network: string;
};
/**
 * Get x402 version from PaymentPayload.
 * Returns literal type 1 | 2 for exhaustiveness checking in switch statements.
 */
declare function getVersion(payload: PaymentPayload): 1 | 2;
/**
 * Safely extract x402 version from an unknown payment object.
 * Provides backward compatibility for pre-versioning payloads.
 *
 * - Returns 1 if x402Version is undefined/missing (backward compatibility)
 * - Returns 1 or 2 for valid versions
 * - Throws descriptive error for unsupported versions
 *
 * Use this at method entry points to validate version before processing.
 * For type-safe access after validation, use getVersion() instead.
 */
declare function getVersionSafe(payment: unknown): 1 | 2;
/**
 * Exhaustiveness check for discriminated unions.
 * TypeScript will error at compile time if not all union members are handled.
 *
 * @example
 * function handlePayload(payload: PaymentPayload) {
 *   switch (payload.x402Version) {
 *     case 1: return handleV1(payload);
 *     case 2: return handleV2(payload);
 *     default: return assertNever(payload);
 *   }
 * }
 */
declare function assertNever(value: never, message?: string): never;

/**
 * Claims module for reporting failures and managing refunds
 */
interface ReportFailureParams {
    /** The facilitator URL (e.g., https://api.openfacilitator.io) */
    facilitatorUrl: string;
    /** The API key from server registration */
    apiKey: string;
    /** The original transaction hash that failed */
    originalTxHash: string;
    /** The user's wallet address to receive the refund */
    userWallet: string;
    /** The amount to refund (in atomic units, e.g., "1000000" for $1 USDC) */
    amount: string;
    /** The asset address (token contract) */
    asset: string;
    /** The network (e.g., "base", "solana") */
    network: string;
    /** Optional reason for the failure */
    reason?: string;
}
interface ReportFailureResponse {
    success: boolean;
    claimId?: string;
    error?: string;
}
/**
 * Report a failure to the facilitator to create a refund claim
 *
 * @example
 * ```typescript
 * import { reportFailure } from '@openfacilitator/sdk/claims';
 *
 * const result = await reportFailure({
 *   facilitatorUrl: 'https://my-facilitator.openfacilitator.io',
 *   apiKey: 'sk_...',
 *   originalTxHash: '0x123...',
 *   userWallet: '0xabc...',
 *   amount: '1000000', // 1 USDC
 *   asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
 *   network: 'base',
 *   reason: 'Service unavailable',
 * });
 *
 * if (result.success) {
 *   console.log('Claim created:', result.claimId);
 * } else {
 *   console.error('Failed to create claim:', result.error);
 * }
 * ```
 */
declare function reportFailure(params: ReportFailureParams): Promise<ReportFailureResponse>;
interface GetClaimableParams {
    /** The facilitator URL */
    facilitatorUrl: string;
    /** The user's wallet address */
    wallet: string;
    /** Optional facilitator subdomain filter */
    facilitator?: string;
}
interface ClaimableItem {
    id: string;
    originalTxHash: string;
    amount: string;
    asset: string;
    network: string;
    reason?: string;
    status: 'pending' | 'approved';
    reportedAt: string;
    expiresAt?: string;
}
interface GetClaimableResponse {
    claims: ClaimableItem[];
}
/**
 * Get claimable refunds for a wallet
 */
declare function getClaimable(params: GetClaimableParams): Promise<GetClaimableResponse>;
interface ClaimHistoryItem {
    id: string;
    originalTxHash: string;
    amount: string;
    asset: string;
    network: string;
    reason?: string;
    status: 'pending' | 'approved' | 'paid' | 'rejected' | 'expired';
    reportedAt: string;
    expiresAt?: string;
    payoutTxHash?: string;
    paidAt?: string;
}
interface GetClaimHistoryResponse {
    claims: ClaimHistoryItem[];
}
/**
 * Get claim history for a wallet
 */
declare function getClaimHistory(params: GetClaimableParams): Promise<GetClaimHistoryResponse>;
interface ExecuteClaimParams {
    /** The facilitator URL */
    facilitatorUrl: string;
    /** The claim ID to execute */
    claimId: string;
    /** Optional signature for verification (recommended in production) */
    signature?: string;
}
interface ExecuteClaimResponse {
    success: boolean;
    transactionHash?: string;
    error?: string;
}
/**
 * Execute a claim payout (claim must be approved)
 */
declare function executeClaim(params: ExecuteClaimParams): Promise<ExecuteClaimResponse>;

/**
 * Payment and refund protection middleware
 */

interface RefundProtectionConfig {
    /** The API key from server registration */
    apiKey: string;
    /** The facilitator URL (required for standalone usage) */
    facilitatorUrl: string;
    /** Optional: Custom error filter - return false to skip reporting */
    shouldReport?: (error: Error) => boolean;
    /** Optional: Called when a failure is reported */
    onReport?: (claimId: string | undefined, error: Error) => void;
    /** Optional: Called when reporting fails */
    onReportError?: (reportError: Error, originalError: Error) => void;
}
/**
 * Refund protection config for use with payment middleware.
 * The facilitatorUrl is optional and defaults to the middleware's facilitator URL.
 */
interface MiddlewareRefundConfig {
    /** The API key from server registration */
    apiKey: string;
    /** The facilitator URL (optional - defaults to the middleware's facilitator URL) */
    facilitatorUrl?: string;
    /** Optional: Custom error filter - return false to skip reporting */
    shouldReport?: (error: Error) => boolean;
    /** Optional: Called when a failure is reported */
    onReport?: (claimId: string | undefined, error: Error) => void;
    /** Optional: Called when reporting fails */
    onReportError?: (reportError: Error, originalError: Error) => void;
}
interface PaymentContext {
    /** Transaction hash from settlement */
    transactionHash: string;
    /** User's wallet address (payer) */
    userWallet: string;
    /** Payment amount in atomic units */
    amount: string;
    /** Asset/token address */
    asset: string;
    /** Network identifier (e.g., "base", "solana") */
    network: string;
}
/**
 * Wrap an async function with refund protection.
 * If the function throws, a failure is automatically reported.
 *
 * @example
 * ```typescript
 * import { withRefundProtection } from '@openfacilitator/sdk';
 *
 * const protectedHandler = withRefundProtection(
 *   {
 *     apiKey: process.env.REFUND_API_KEY!,
 *     facilitatorUrl: 'https://free.openfacilitator.xyz',
 *   },
 *   async (paymentContext) => {
 *     // Your logic here - if this throws, failure is auto-reported
 *     const result = await doExpensiveOperation();
 *     return result;
 *   }
 * );
 *
 * // Call with payment context from settle response
 * const result = await protectedHandler({
 *   transactionHash: settleResponse.transaction,
 *   userWallet: settleResponse.payer,
 *   amount: paymentPayload.payload.authorization.amount,
 *   asset: paymentPayload.payload.authorization.asset,
 *   network: settleResponse.network,
 * });
 * ```
 */
declare function withRefundProtection<T>(config: RefundProtectionConfig, handler: (context: PaymentContext) => Promise<T>): (context: PaymentContext) => Promise<T>;
/**
 * Express request with payment context attached
 */
interface PaymentRequest {
    paymentContext?: PaymentContext;
}
/**
 * Create Express middleware that attaches payment context and reports failures.
 *
 * @example
 * ```typescript
 * import express from 'express';
 * import { createRefundMiddleware } from '@openfacilitator/sdk';
 *
 * const app = express();
 *
 * const refundMiddleware = createRefundMiddleware({
 *   apiKey: process.env.REFUND_API_KEY!,
 *   facilitatorUrl: 'https://free.openfacilitator.xyz',
 * });
 *
 * // Apply after your x402 payment verification
 * app.post('/api/resource', paymentMiddleware, refundMiddleware, async (req, res) => {
 *   // If this throws, failure is auto-reported
 *   const result = await doExpensiveOperation();
 *   res.json(result);
 * });
 * ```
 */
declare function createRefundMiddleware(config: RefundProtectionConfig): (req: PaymentRequest & {
    body?: unknown;
}, res: {
    locals?: {
        paymentContext?: PaymentContext;
    };
}, next: (error?: unknown) => void) => Promise<void>;
/**
 * Create Hono middleware for refund protection.
 *
 * @example
 * ```typescript
 * import { Hono } from 'hono';
 * import { honoRefundMiddleware } from '@openfacilitator/sdk';
 *
 * const app = new Hono();
 *
 * // Apply after your x402 payment verification
 * app.post('/api/resource', paymentMiddleware, honoRefundMiddleware({
 *   apiKey: process.env.REFUND_API_KEY!,
 *   facilitatorUrl: 'https://free.openfacilitator.xyz',
 *   getPaymentContext: (c) => c.get('paymentContext'),
 * }), async (c) => {
 *   const result = await doExpensiveOperation();
 *   return c.json(result);
 * });
 * ```
 */
interface HonoRefundConfig extends RefundProtectionConfig {
    /** Function to extract payment context from Hono context */
    getPaymentContext: (c: HonoContext) => PaymentContext | undefined;
}
interface HonoContext {
    get: (key: string) => unknown;
    set: (key: string, value: unknown) => void;
}
declare function honoRefundMiddleware(config: HonoRefundConfig): (c: HonoContext, next: () => Promise<void>) => Promise<void>;
/**
 * Helper to create PaymentContext from settle response and payment payload.
 *
 * @example
 * ```typescript
 * import { OpenFacilitator, createPaymentContext } from '@openfacilitator/sdk';
 *
 * const facilitator = new OpenFacilitator({ url: '...' });
 * const settleResult = await facilitator.settle(paymentPayload, requirements);
 *
 * const paymentContext = createPaymentContext(settleResult, paymentPayload);
 * // Use with withRefundProtection or attach to request
 * ```
 */
declare function createPaymentContext(settleResponse: {
    transaction: string;
    payer: string;
    network: string;
}, paymentPayload: Record<string, unknown>, requirements?: {
    maxAmountRequired?: string;
    amount?: string;
    asset?: string;
}): PaymentContext;
interface PaymentMiddlewareConfig {
    /** Facilitator instance or URL */
    facilitator: OpenFacilitator | string;
    /** Function to get payment requirements for the request (single or multiple for multi-network) */
    getRequirements: (req: unknown) => PaymentRequirements | PaymentRequirements[] | Promise<PaymentRequirements | PaymentRequirements[]>;
    /** Optional: Refund protection config (enables auto failure reporting) */
    refundProtection?: MiddlewareRefundConfig;
    /** Optional: Custom 402 response handler */
    on402?: (req: unknown, res: unknown, requirements: PaymentRequirements[]) => void | Promise<void>;
}
/**
 * Create x402 payment middleware that handles verification, settlement, and optional refund protection.
 *
 * @example
 * ```typescript
 * import express from 'express';
 * import { createPaymentMiddleware, OpenFacilitator } from '@openfacilitator/sdk';
 *
 * const app = express();
 *
 * const paymentMiddleware = createPaymentMiddleware({
 *   facilitator: new OpenFacilitator({ url: 'https://free.openfacilitator.xyz' }),
 *   getRequirements: (req) => ({
 *     scheme: 'exact',
 *     network: 'base',
 *     maxAmountRequired: '1000000', // $1 USDC
 *     asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
 *     payTo: '0xYourAddress',
 *     resource: req.url,
 *   }),
 *   refundProtection: {
 *     apiKey: process.env.REFUND_API_KEY!,
 *     facilitatorUrl: 'https://free.openfacilitator.xyz',
 *   },
 * });
 *
 * app.post('/api/resource', paymentMiddleware, async (req, res) => {
 *   // Payment verified & settled, refund protection active
 *   const result = await doExpensiveOperation();
 *   res.json(result);
 * });
 * ```
 */
declare function createPaymentMiddleware(config: PaymentMiddlewareConfig): (req: {
    headers: Record<string, string | string[] | undefined>;
    url?: string;
    paymentContext?: PaymentContext;
}, res: {
    status: (code: number) => {
        json: (body: unknown) => void;
    };
    locals?: Record<string, unknown>;
}, next: (error?: unknown) => void) => Promise<void>;
interface HonoPaymentConfig {
    /** Facilitator instance or URL */
    facilitator: OpenFacilitator | string;
    /** Function to get payment requirements for the request (single or multiple for multi-network) */
    getRequirements: (c: HonoContext) => PaymentRequirements | PaymentRequirements[] | Promise<PaymentRequirements | PaymentRequirements[]>;
    /** Optional: Refund protection config */
    refundProtection?: MiddlewareRefundConfig;
}
/**
 * Create Hono x402 payment middleware.
 *
 * @example
 * ```typescript
 * import { Hono } from 'hono';
 * import { honoPaymentMiddleware, OpenFacilitator } from '@openfacilitator/sdk';
 *
 * const app = new Hono();
 *
 * app.post('/api/resource', honoPaymentMiddleware({
 *   facilitator: new OpenFacilitator({ url: 'https://free.openfacilitator.xyz' }),
 *   getRequirements: (c) => ({
 *     scheme: 'exact',
 *     network: 'base',
 *     maxAmountRequired: '1000000',
 *     asset: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
 *     payTo: '0xYourAddress',
 *   }),
 *   refundProtection: {
 *     apiKey: process.env.REFUND_API_KEY!,
 *     facilitatorUrl: 'https://free.openfacilitator.xyz',
 *   },
 * }), async (c) => {
 *   const paymentContext = c.get('paymentContext');
 *   const result = await doExpensiveOperation();
 *   return c.json(result);
 * });
 * ```
 */
declare function honoPaymentMiddleware(config: HonoPaymentConfig): (c: HonoContext & {
    req: {
        header: (name: string) => string | undefined;
        url: string;
    };
    json: (body: unknown, status?: number) => Response;
}, next: () => Promise<void>) => Promise<Response | undefined>;

export { type ClaimHistoryItem, type ClaimableItem, ConfigurationError, type ExecuteClaimParams, type ExecuteClaimResponse, type FacilitatorConfig, FacilitatorError, type GetClaimHistoryResponse, type GetClaimableParams, type GetClaimableResponse, type HonoPaymentConfig, type HonoRefundConfig, type MiddlewareRefundConfig, NETWORKS, NetworkError, type NetworkInfo, type NetworkType, OpenFacilitator, type PaymentAuthorization, type PaymentContext, type PaymentKind, type PaymentMiddlewareConfig, type PaymentPayload, type PaymentPayloadV1, type PaymentPayloadV2, type PaymentRequest, type PaymentRequirements, type PaymentRequirementsV1, type PaymentRequirementsV2, type RefundProtectionConfig, type ReportFailureParams, type ReportFailureResponse, type SettleResponse, SettlementError, type SupportedResponse, VerificationError, type VerifyResponse, assertNever, createDefaultFacilitator, createPaymentContext, createPaymentMiddleware, createRefundMiddleware, executeClaim, getClaimHistory, getClaimable, getMainnets, getNetwork, getNetworkType, getSchemeNetwork, getTestnets, getVersion, getVersionSafe, honoPaymentMiddleware, honoRefundMiddleware, isPaymentPayload, isPaymentPayloadV1, isPaymentPayloadV2, isPaymentRequirementsV1, isPaymentRequirementsV2, isValidNetwork, reportFailure, toV1NetworkId, toV2NetworkId, withRefundProtection };
