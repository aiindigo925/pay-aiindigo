// src/errors.ts
var FacilitatorError = class extends Error {
  constructor(message, code, statusCode, details) {
    super(message);
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    this.name = "FacilitatorError";
  }
};
var NetworkError = class extends FacilitatorError {
  constructor(message, details) {
    super(message, "NETWORK_ERROR", void 0, details);
    this.name = "NetworkError";
  }
};
var VerificationError = class extends FacilitatorError {
  constructor(message, details) {
    super(message, "VERIFICATION_ERROR", void 0, details);
    this.name = "VerificationError";
  }
};
var SettlementError = class extends FacilitatorError {
  constructor(message, details) {
    super(message, "SETTLEMENT_ERROR", void 0, details);
    this.name = "SettlementError";
  }
};
var ConfigurationError = class extends FacilitatorError {
  constructor(message) {
    super(message, "CONFIGURATION_ERROR");
    this.name = "ConfigurationError";
  }
};

// src/utils.ts
function normalizeUrl(url) {
  return url.replace(/\/+$/, "");
}
function buildUrl(baseUrl, path) {
  return `${normalizeUrl(baseUrl)}${path}`;
}
function isPaymentPayload(value) {
  if (!value || typeof value !== "object") return false;
  const obj = value;
  if (obj.x402Version === 1) {
    return typeof obj.scheme === "string" && typeof obj.network === "string" && obj.payload !== void 0;
  } else if (obj.x402Version === 2) {
    const accepted = obj.accepted;
    return accepted !== void 0 && typeof accepted === "object" && typeof accepted.scheme === "string" && typeof accepted.network === "string" && obj.payload !== void 0;
  }
  return false;
}
function isPaymentPayloadV1(value) {
  if (!value || typeof value !== "object") return false;
  const obj = value;
  return obj.x402Version === 1 && typeof obj.scheme === "string" && typeof obj.network === "string" && obj.payload !== void 0 && typeof obj.payload === "object";
}
function isPaymentPayloadV2(value) {
  if (!value || typeof value !== "object") return false;
  const obj = value;
  if (obj.x402Version !== 2) return false;
  const accepted = obj.accepted;
  return accepted !== void 0 && typeof accepted === "object" && typeof accepted.scheme === "string" && typeof accepted.network === "string" && typeof accepted.asset === "string" && typeof accepted.amount === "string" && typeof accepted.payTo === "string" && typeof accepted.maxTimeoutSeconds === "number" && obj.payload !== void 0;
}
function isPaymentRequirementsV1(value) {
  if (!value || typeof value !== "object") return false;
  return "maxAmountRequired" in value;
}
function isPaymentRequirementsV2(value) {
  if (!value || typeof value !== "object") return false;
  return "amount" in value && !("maxAmountRequired" in value);
}
function getSchemeNetwork(payload) {
  if (payload.x402Version === 1) {
    return {
      scheme: payload.scheme,
      network: payload.network
    };
  } else {
    return {
      scheme: payload.accepted.scheme,
      network: payload.accepted.network
    };
  }
}
function getVersion(payload) {
  return payload.x402Version;
}
function getVersionSafe(payment) {
  if (!payment || typeof payment !== "object") {
    return 1;
  }
  const obj = payment;
  const version = obj.x402Version;
  if (version === void 0) return 1;
  if (version === 1 || version === 2) return version;
  throw new Error(
    `Unsupported x402 version: ${version}. SDK supports versions 1 and 2.`
  );
}
function assertNever(value, message) {
  throw new Error(
    message ?? `Unhandled discriminated union member: ${JSON.stringify(value)}`
  );
}

// src/client.ts
var DEFAULT_TIMEOUT = 3e4;
var DEFAULT_URL = "https://pay.openfacilitator.io";
var OpenFacilitator = class {
  constructor(config = {}) {
    this.supportedCache = null;
    this.supportedPromise = null;
    this.baseUrl = normalizeUrl(config.url ?? DEFAULT_URL);
    this.timeout = config.timeout ?? DEFAULT_TIMEOUT;
    this.headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
  }
  /**
   * Get the facilitator URL
   */
  get url() {
    return this.baseUrl;
  }
  /**
   * Verify a payment is valid
   * @param payment - The payment payload
   * @param requirements - Payment requirements for validation
   */
  async verify(payment, requirements) {
    try {
      const version = getVersionSafe(payment);
      const body = {
        x402Version: version,
        paymentPayload: payment,
        paymentRequirements: requirements
      };
      const response = await this.request("/verify", {
        method: "POST",
        body: JSON.stringify(body)
      });
      return response;
    } catch (error) {
      if (error instanceof FacilitatorError) throw error;
      throw new VerificationError(
        `Verification failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        error
      );
    }
  }
  /**
   * Settle/broadcast a payment transaction
   * @param payment - The payment payload
   * @param requirements - Payment requirements for validation
   */
  async settle(payment, requirements) {
    try {
      const version = getVersionSafe(payment);
      const body = {
        x402Version: version,
        paymentPayload: payment,
        paymentRequirements: requirements
      };
      const response = await this.request("/settle", {
        method: "POST",
        body: JSON.stringify(body)
      });
      return response;
    } catch (error) {
      if (error instanceof FacilitatorError) throw error;
      throw new SettlementError(
        `Settlement failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        error
      );
    }
  }
  /**
   * Get supported networks and payment kinds
   */
  async supported() {
    try {
      const response = await this.request("/supported", {
        method: "GET"
      });
      return response;
    } catch (error) {
      if (error instanceof FacilitatorError) throw error;
      throw new NetworkError(
        `Failed to fetch supported networks: ${error instanceof Error ? error.message : "Unknown error"}`,
        error
      );
    }
  }
  /**
   * Health check - verify facilitator is reachable
   */
  async health() {
    try {
      await this.supported();
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Get fee payer address for a specific network.
   * Fee payers are wallet addresses that pay transaction fees when settling payments.
   * Currently only Solana networks have fee payers.
   * @param network - Network identifier (e.g., "solana", "solana:mainnet")
   * @returns Fee payer address or undefined if not available for the network
   */
  async getFeePayer(network) {
    const supported = await this.getSupportedCached();
    for (const kind of supported.kinds) {
      if (kind.network === network || kind.network.includes(network) || network.includes(kind.network)) {
        if (kind.extra?.feePayer) {
          return kind.extra.feePayer;
        }
      }
    }
    return void 0;
  }
  /**
   * Get all fee payers mapped by network.
   * Fee payers are wallet addresses that pay transaction fees when settling payments.
   * @returns Map of network identifiers to fee payer addresses
   */
  async getFeePayerMap() {
    const supported = await this.getSupportedCached();
    const feePayerMap = {};
    for (const kind of supported.kinds) {
      if (kind.extra?.feePayer) {
        feePayerMap[kind.network] = kind.extra.feePayer;
      }
    }
    return feePayerMap;
  }
  /**
   * Get cached supported response, fetching if needed.
   * Uses deduplication to prevent concurrent requests.
   */
  async getSupportedCached() {
    if (this.supportedCache) {
      return this.supportedCache;
    }
    if (!this.supportedPromise) {
      this.supportedPromise = this.supported().then((response) => {
        this.supportedCache = response;
        this.supportedPromise = null;
        return response;
      });
    }
    return this.supportedPromise;
  }
  /**
   * Clear cached supported response.
   * Useful if facilitator configuration may have changed.
   */
  clearCache() {
    this.supportedCache = null;
    this.supportedPromise = null;
  }
  /**
   * Internal request helper
   */
  async request(path, init) {
    const url = buildUrl(this.baseUrl, path);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const response = await fetch(url, {
        ...init,
        headers: {
          ...this.headers,
          ...init.headers
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        let errorMessage = `HTTP ${response.status}`;
        try {
          const errorBody = await response.json();
          errorMessage = errorBody.error || errorBody.message || errorMessage;
        } catch {
        }
        throw new FacilitatorError(errorMessage, "HTTP_ERROR", response.status);
      }
      return await response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof FacilitatorError) throw error;
      if (error instanceof Error && error.name === "AbortError") {
        throw new NetworkError(`Request timeout after ${this.timeout}ms`);
      }
      throw new NetworkError(
        `Request failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        error
      );
    }
  }
};
function createDefaultFacilitator() {
  return new OpenFacilitator();
}

// src/networks.ts
var NETWORKS = [
  // EVM Mainnets
  { v1Id: "base", v2Id: "eip155:8453", name: "Base", type: "evm", chainId: 8453, testnet: false },
  { v1Id: "polygon", v2Id: "eip155:137", name: "Polygon", type: "evm", chainId: 137, testnet: false },
  { v1Id: "avalanche", v2Id: "eip155:43114", name: "Avalanche", type: "evm", chainId: 43114, testnet: false },
  { v1Id: "sei", v2Id: "eip155:1329", name: "Sei", type: "evm", chainId: 1329, testnet: false },
  { v1Id: "iotex", v2Id: "eip155:4689", name: "IoTeX", type: "evm", chainId: 4689, testnet: false },
  { v1Id: "peaq", v2Id: "eip155:3338", name: "Peaq", type: "evm", chainId: 3338, testnet: false },
  { v1Id: "xlayer", v2Id: "eip155:196", name: "X Layer", type: "evm", chainId: 196, testnet: false },
  // EVM Testnets
  { v1Id: "base-sepolia", v2Id: "eip155:84532", name: "Base Sepolia", type: "evm", chainId: 84532, testnet: true },
  { v1Id: "polygon-amoy", v2Id: "eip155:80002", name: "Polygon Amoy", type: "evm", chainId: 80002, testnet: true },
  { v1Id: "avalanche-fuji", v2Id: "eip155:43113", name: "Avalanche Fuji", type: "evm", chainId: 43113, testnet: true },
  { v1Id: "sei-testnet", v2Id: "eip155:1328", name: "Sei Testnet", type: "evm", chainId: 1328, testnet: true },
  { v1Id: "xlayer-testnet", v2Id: "eip155:195", name: "X Layer Testnet", type: "evm", chainId: 195, testnet: true },
  // Solana
  { v1Id: "solana", v2Id: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", name: "Solana", type: "solana", testnet: false },
  { v1Id: "solana-devnet", v2Id: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1", name: "Solana Devnet", type: "solana", testnet: true }
];
function getNetwork(id) {
  return NETWORKS.find((n) => n.v1Id === id || n.v2Id === id);
}
function getNetworkType(id) {
  const network = getNetwork(id);
  if (network) return network.type;
  if (id.startsWith("eip155:")) return "evm";
  if (id.startsWith("solana:")) return "solana";
  return void 0;
}
function toV2NetworkId(id) {
  const network = getNetwork(id);
  return network?.v2Id ?? id;
}
function toV1NetworkId(id) {
  const network = getNetwork(id);
  return network?.v1Id ?? id;
}
function isValidNetwork(id) {
  return getNetwork(id) !== void 0;
}
function getMainnets() {
  return NETWORKS.filter((n) => !n.testnet);
}
function getTestnets() {
  return NETWORKS.filter((n) => n.testnet);
}

// src/claims.ts
async function reportFailure(params) {
  const {
    facilitatorUrl,
    apiKey,
    originalTxHash,
    userWallet,
    amount,
    asset,
    network,
    reason
  } = params;
  const baseUrl = facilitatorUrl.replace(/\/$/, "");
  try {
    const response = await fetch(`${baseUrl}/claims/report-failure`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Server-Api-Key": apiKey
      },
      body: JSON.stringify({
        originalTxHash,
        userWallet,
        amount,
        asset,
        network,
        reason
      })
    });
    const data = await response.json();
    if (!response.ok) {
      return {
        success: false,
        error: data.error || `HTTP ${response.status}`
      };
    }
    return data;
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function getClaimable(params) {
  const { facilitatorUrl, wallet, facilitator } = params;
  const baseUrl = facilitatorUrl.replace(/\/$/, "");
  const queryParams = new URLSearchParams({ wallet });
  if (facilitator) {
    queryParams.set("facilitator", facilitator);
  }
  const response = await fetch(`${baseUrl}/api/claims?${queryParams.toString()}`);
  const data = await response.json();
  if (!response.ok) {
    throw new Error(data.error || `HTTP ${response.status}`);
  }
  return data;
}
async function getClaimHistory(params) {
  const { facilitatorUrl, wallet, facilitator } = params;
  const baseUrl = facilitatorUrl.replace(/\/$/, "");
  const queryParams = new URLSearchParams({ wallet });
  if (facilitator) {
    queryParams.set("facilitator", facilitator);
  }
  const response = await fetch(`${baseUrl}/api/claims/history?${queryParams.toString()}`);
  const data = await response.json();
  if (!response.ok) {
    throw new Error(data.error || `HTTP ${response.status}`);
  }
  return data;
}
async function executeClaim(params) {
  const { facilitatorUrl, claimId, signature } = params;
  const baseUrl = facilitatorUrl.replace(/\/$/, "");
  try {
    const response = await fetch(`${baseUrl}/api/claims/${claimId}/execute`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ signature })
    });
    const data = await response.json();
    if (!response.ok) {
      return {
        success: false,
        error: data.error || `HTTP ${response.status}`
      };
    }
    return data;
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}

// src/middleware.ts
function withRefundProtection(config, handler) {
  return async (context) => {
    try {
      return await handler(context);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      if (config.shouldReport && !config.shouldReport(err)) {
        throw error;
      }
      try {
        const result = await reportFailure({
          facilitatorUrl: config.facilitatorUrl,
          apiKey: config.apiKey,
          originalTxHash: context.transactionHash,
          userWallet: context.userWallet,
          amount: context.amount,
          asset: context.asset,
          network: context.network,
          reason: err.message
        });
        if (config.onReport) {
          config.onReport(result.claimId, err);
        }
      } catch (reportError) {
        if (config.onReportError) {
          config.onReportError(
            reportError instanceof Error ? reportError : new Error(String(reportError)),
            err
          );
        }
      }
      throw error;
    }
  };
}
function createRefundMiddleware(config) {
  return async (req, res, next) => {
    const originalNext = next;
    const paymentContext = res.locals?.paymentContext || req.paymentContext;
    if (!paymentContext) {
      return originalNext();
    }
    const wrappedNext = async (error) => {
      if (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        if (!config.shouldReport || config.shouldReport(err)) {
          try {
            const result = await reportFailure({
              facilitatorUrl: config.facilitatorUrl,
              apiKey: config.apiKey,
              originalTxHash: paymentContext.transactionHash,
              userWallet: paymentContext.userWallet,
              amount: paymentContext.amount,
              asset: paymentContext.asset,
              network: paymentContext.network,
              reason: err.message
            });
            if (config.onReport) {
              config.onReport(result.claimId, err);
            }
          } catch (reportError) {
            if (config.onReportError) {
              config.onReportError(
                reportError instanceof Error ? reportError : new Error(String(reportError)),
                err
              );
            }
          }
        }
      }
      originalNext(error);
    };
    next = wrappedNext;
    originalNext();
  };
}
function honoRefundMiddleware(config) {
  return async (c, next) => {
    const paymentContext = config.getPaymentContext(c);
    if (!paymentContext) {
      return next();
    }
    try {
      await next();
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      if (!config.shouldReport || config.shouldReport(err)) {
        try {
          const result = await reportFailure({
            facilitatorUrl: config.facilitatorUrl,
            apiKey: config.apiKey,
            originalTxHash: paymentContext.transactionHash,
            userWallet: paymentContext.userWallet,
            amount: paymentContext.amount,
            asset: paymentContext.asset,
            network: paymentContext.network,
            reason: err.message
          });
          if (config.onReport) {
            config.onReport(result.claimId, err);
          }
        } catch (reportError) {
          if (config.onReportError) {
            config.onReportError(
              reportError instanceof Error ? reportError : new Error(String(reportError)),
              err
            );
          }
        }
      }
      throw error;
    }
  };
}
function createPaymentContext(settleResponse, paymentPayload, requirements) {
  const payload = paymentPayload.payload;
  const authorization = payload?.authorization;
  const amount = authorization?.amount || payload?.amount || requirements?.amount || requirements?.maxAmountRequired || "0";
  const asset = authorization?.asset || payload?.asset || requirements?.asset || "";
  return {
    transactionHash: settleResponse.transaction,
    userWallet: settleResponse.payer,
    amount,
    asset,
    network: settleResponse.network
  };
}
function createPaymentMiddleware(config) {
  const facilitator = typeof config.facilitator === "string" ? new OpenFacilitator({ url: config.facilitator }) : config.facilitator;
  return async (req, res, next) => {
    try {
      const rawRequirements = await config.getRequirements(req);
      const requirementsArray = Array.isArray(rawRequirements) ? rawRequirements : [rawRequirements];
      const paymentHeader = req.headers["x-payment"];
      const paymentString = Array.isArray(paymentHeader) ? paymentHeader[0] : paymentHeader;
      if (!paymentString) {
        if (config.on402) {
          await config.on402(req, res, requirementsArray);
        } else {
          const accepts = requirementsArray.map((requirements2) => {
            const extra = {
              ...requirements2.extra
            };
            if (config.refundProtection) {
              extra.supportsRefunds = true;
            }
            if ("maxAmountRequired" in requirements2) {
              return {
                scheme: requirements2.scheme,
                network: requirements2.network,
                maxAmountRequired: requirements2.maxAmountRequired,
                asset: requirements2.asset,
                payTo: requirements2.payTo,
                resource: requirements2.resource || req.url,
                description: requirements2.description,
                ...Object.keys(extra).length > 0 ? { extra } : {}
              };
            } else {
              return {
                scheme: requirements2.scheme,
                network: requirements2.network,
                amount: requirements2.amount,
                asset: requirements2.asset,
                payTo: requirements2.payTo,
                maxTimeoutSeconds: requirements2.maxTimeoutSeconds,
                extra: { ...extra, ...requirements2.extra }
              };
            }
          });
          res.status(402).json({
            x402Version: 2,
            error: "Payment Required",
            accepts
          });
        }
        return;
      }
      let paymentPayload;
      try {
        const decoded = Buffer.from(paymentString, "base64").toString("utf-8");
        paymentPayload = JSON.parse(decoded);
        if (!isPaymentPayload(paymentPayload)) {
          throw new Error("Invalid payment payload structure");
        }
      } catch {
        res.status(400).json({ error: "Invalid X-PAYMENT header" });
        return;
      }
      const paymentNetwork = paymentPayload.x402Version === 2 ? paymentPayload.accepted?.network : paymentPayload.network;
      const requirements = requirementsArray.find((r) => r.network === paymentNetwork) || requirementsArray[0];
      const verifyResult = await facilitator.verify(paymentPayload, requirements);
      if (!verifyResult.isValid) {
        res.status(402).json({
          error: "Payment verification failed",
          reason: verifyResult.invalidReason
        });
        return;
      }
      const settleResult = await facilitator.settle(paymentPayload, requirements);
      if (!settleResult.success) {
        res.status(402).json({
          error: "Payment settlement failed",
          reason: settleResult.errorReason
        });
        return;
      }
      const paymentContext = createPaymentContext(settleResult, paymentPayload, requirements);
      req.paymentContext = paymentContext;
      if (res.locals) {
        res.locals.paymentContext = paymentContext;
      }
      if (config.refundProtection) {
        const originalNext = next;
        const refundConfig = config.refundProtection;
        const refundFacilitatorUrl = refundConfig.facilitatorUrl || facilitator.url;
        next = async (error) => {
          if (error) {
            const err = error instanceof Error ? error : new Error(String(error));
            if (!refundConfig.shouldReport || refundConfig.shouldReport(err)) {
              try {
                const result = await reportFailure({
                  facilitatorUrl: refundFacilitatorUrl,
                  apiKey: refundConfig.apiKey,
                  originalTxHash: paymentContext.transactionHash,
                  userWallet: paymentContext.userWallet,
                  amount: paymentContext.amount,
                  asset: paymentContext.asset,
                  network: paymentContext.network,
                  reason: err.message
                });
                if (refundConfig.onReport) {
                  refundConfig.onReport(result.claimId, err);
                }
              } catch (reportError) {
                if (refundConfig.onReportError) {
                  refundConfig.onReportError(
                    reportError instanceof Error ? reportError : new Error(String(reportError)),
                    err
                  );
                }
              }
            }
          }
          originalNext(error);
        };
      }
      next();
    } catch (error) {
      next(error);
    }
  };
}
function honoPaymentMiddleware(config) {
  const facilitator = typeof config.facilitator === "string" ? new OpenFacilitator({ url: config.facilitator }) : config.facilitator;
  return async (c, next) => {
    const rawRequirements = await config.getRequirements(c);
    const requirementsArray = Array.isArray(rawRequirements) ? rawRequirements : [rawRequirements];
    const paymentString = c.req.header("x-payment");
    if (!paymentString) {
      const accepts = requirementsArray.map((requirements2) => {
        const extra = {
          ...requirements2.extra
        };
        if (config.refundProtection) {
          extra.supportsRefunds = true;
        }
        if ("maxAmountRequired" in requirements2) {
          return {
            scheme: requirements2.scheme,
            network: requirements2.network,
            maxAmountRequired: requirements2.maxAmountRequired,
            asset: requirements2.asset,
            payTo: requirements2.payTo,
            resource: requirements2.resource || c.req.url,
            description: requirements2.description,
            ...Object.keys(extra).length > 0 ? { extra } : {}
          };
        } else {
          return {
            scheme: requirements2.scheme,
            network: requirements2.network,
            amount: requirements2.amount,
            asset: requirements2.asset,
            payTo: requirements2.payTo,
            maxTimeoutSeconds: requirements2.maxTimeoutSeconds,
            extra: { ...extra, ...requirements2.extra }
          };
        }
      });
      return c.json({
        x402Version: 2,
        error: "Payment Required",
        accepts
      }, 402);
    }
    let paymentPayload;
    try {
      const decoded = atob(paymentString);
      paymentPayload = JSON.parse(decoded);
      if (!isPaymentPayload(paymentPayload)) {
        throw new Error("Invalid payment payload structure");
      }
    } catch {
      return c.json({ error: "Invalid X-PAYMENT header" }, 400);
    }
    const paymentNetwork = paymentPayload.x402Version === 2 ? paymentPayload.accepted?.network : paymentPayload.network;
    const requirements = requirementsArray.find((r) => r.network === paymentNetwork) || requirementsArray[0];
    const verifyResult = await facilitator.verify(paymentPayload, requirements);
    if (!verifyResult.isValid) {
      return c.json({
        error: "Payment verification failed",
        reason: verifyResult.invalidReason
      }, 402);
    }
    const settleResult = await facilitator.settle(paymentPayload, requirements);
    if (!settleResult.success) {
      return c.json({
        error: "Payment settlement failed",
        reason: settleResult.errorReason
      }, 402);
    }
    const paymentContext = createPaymentContext(settleResult, paymentPayload, requirements);
    c.set("paymentContext", paymentContext);
    if (config.refundProtection) {
      const refundConfig = config.refundProtection;
      const refundFacilitatorUrl = refundConfig.facilitatorUrl || facilitator.url;
      try {
        await next();
      } catch (error) {
        const err = error instanceof Error ? error : new Error(String(error));
        if (!refundConfig.shouldReport || refundConfig.shouldReport(err)) {
          try {
            const result = await reportFailure({
              facilitatorUrl: refundFacilitatorUrl,
              apiKey: refundConfig.apiKey,
              originalTxHash: paymentContext.transactionHash,
              userWallet: paymentContext.userWallet,
              amount: paymentContext.amount,
              asset: paymentContext.asset,
              network: paymentContext.network,
              reason: err.message
            });
            if (refundConfig.onReport) {
              refundConfig.onReport(result.claimId, err);
            }
          } catch (reportError) {
            if (refundConfig.onReportError) {
              refundConfig.onReportError(
                reportError instanceof Error ? reportError : new Error(String(reportError)),
                err
              );
            }
          }
        }
        throw error;
      }
    } else {
      await next();
    }
  };
}
export {
  ConfigurationError,
  FacilitatorError,
  NETWORKS,
  NetworkError,
  OpenFacilitator,
  SettlementError,
  VerificationError,
  assertNever,
  createDefaultFacilitator,
  createPaymentContext,
  createPaymentMiddleware,
  createRefundMiddleware,
  executeClaim,
  getClaimHistory,
  getClaimable,
  getMainnets,
  getNetwork,
  getNetworkType,
  getSchemeNetwork,
  getTestnets,
  getVersion,
  getVersionSafe,
  honoPaymentMiddleware,
  honoRefundMiddleware,
  isPaymentPayload,
  isPaymentPayloadV1,
  isPaymentPayloadV2,
  isPaymentRequirementsV1,
  isPaymentRequirementsV2,
  isValidNetwork,
  reportFailure,
  toV1NetworkId,
  toV2NetworkId,
  withRefundProtection
};
